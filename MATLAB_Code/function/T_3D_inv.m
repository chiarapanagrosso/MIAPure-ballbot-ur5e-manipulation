%% Spherical Wheel to Omni-Wheel Torque Conversion (Corrected)
% This function calculates the required omniwheel torques (tau_W) for a
% desired spherical wheel torque (tau_S).
% The rotation model has been corrected to reflect the physical geometry,
% which resolves the singularity issue and produces a full-rank matrix.

function tau_W = T_3D_inv(r_S, r_W, tau_S)
    % INPUTS:
    % r_S:   Radius of the spherical wheel (m)
    % r_W:   Radius of the omni-wheels (m)
    % tau_S: Desired 3x1 torque vector on the spherical wheel [τx; τy; -τz] (Nm)
    %
    % OUTPUT:
    % tau_W: Required 3x1 torque vector for the omni-wheels [τ1; τ2; τ3] (Nm)

    % Define the geometric configuration of the omni-wheels.
    % alpha: Contact angle with the vertical axis.
    % beta:  Angular positions of the three omni-wheels around the sphere.
    alpha = pi / 4; % 45 degrees, as in your code
    beta = [0, 2*pi/3, 4*pi/3];

    % Initialize the torque allocation matrix G (also called T_3D in the paper).
    G = zeros(3, 3);

    % Loop through each of the three omni-wheels to build the G matrix.
    for i = 1:length(beta)
        % --- FINAL CORRECTED ROTATION ---
        % The physically correct model is a tilt around the local Y-axis
        % followed by a placement rotation around the global Z-axis.
        % This differs from the model described in the paper's appendix.
        Rot_mat = Rot_z(beta(i)) * Rot_y(alpha);

        % The torque generated by the omni-wheel is in the direction of the
        % negative local x-axis (-e_Wx) after the rotations.
        e_Wx = Rot_mat(:, 1);

        % The i-th column of the allocation matrix G is the torque vector
        % produced by a unit torque from the i-th motor.
        G(:, i) = (r_S / r_W) * (-e_Wx);
    end

    % Check if the resulting matrix G is invertible. A rank < 3 indicates a
    % singular matrix, which means the torques cannot be uniquely determined.
    if rank(G) < 3
        error('The matrix G is singular and cannot be inverted. Check the geometry.');
    end

    % To find the required omni-wheel torques (tau_W), we solve the system:
    % tau_S = G * tau_W  =>  tau_W = inv(G) * tau_S
    tau_W = G \ tau_S; % Using backslash is more numerically stable than inv(G)*tau_S
end

% Helper function for rotation around the Z-axis
function Rz = Rot_z(ang)
    Rz = [cos(ang), -sin(ang), 0;
          sin(ang),  cos(ang), 0;
          0,         0,        1];
end

% Helper function for rotation around the X-axis
function Rx = Rot_x(ang)
    Rx = [1, 0,         0;
          0, cos(ang), -sin(ang);
          0, sin(ang),  cos(ang)];
end

% Helper function for rotation around the Y-axis
function Ry = Rot_y(ang)
    Ry = [cos(ang),  0, sin(ang);
          0,         1, 0;
         -sin(ang), 0, cos(ang)];
end
